<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title> </title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Passphrase"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"1d98068404ada19ebdf3afb7a2c22823080ca279de059093d5d37d2f52005b6f263421030bda71aa17125c84ed7657f83132e1cb923eabb8f1320edfb49f878c7ed83446f5e86992872b21635b3ce34a8fbe179ff8be89deb9b1e9c1bea0da2f0738eb524245321b559e41b7b46839d16f266b2cb7228316df38d1ba1e3d42b34941e3647daf25c350ac63eeb9dcca64396086d5cb5de1a4b4146700f7897d558ff2426d42643b3b92cb7c3a11689728a74d5dbf799fb9ef7f7862cb389cbe653fa03d127cbb139125b2ed94eda3af3ad1d87e110b351ee182eb74d81fab99e83f9dd1c01f27ac48812935f08f1655c972d9c2c2bfe0a0285a5d67ee02f3bfff215831969b37a046b05b1ba646d148fbcc1bba894e219dfcc61c875638af894e9b05e64904603555727f198a78750df8a95d3073e13022f8f91f006d68642dd4d63b10db4a1f6b8ffbf16200093cb7f0d3fb952f03009837976ade04cac339f2d01ddf4e9d02ec268b694a9e045d5672ee998d7d2ac0cf47f9de971b5dc7204800df7957abbac4ac32f2cb6bc54fe734dca9ac290b27df1583107937a78b6b17f891f41b89cfb0808c8f43249212a7f0c69fb7beed2e4cfed81974f2bc0220a8560333d03b9f7b66c86b0863969d05e1c80b6a5d24414da1a26a577ebe75421965ca7b35e09dd68739b28e6d7890ada0fa3f8708e0c71ad94f7c25e5ae8918146f2501c532138d97762120c8e817c83a0a9a20c825fed2eb80e01d1c16519312b8c0bd1743167961d67e9db1148dce0ea8b873cf9e1931a30118bfe98a3f63aeeb091909a843c4a5ce9bd46e301fc8e23da394f348f930442f3dce5c9b149fbab2bfc83dccd4f0f772974aebfee22acd1747db855604ef63534ef7561a9d92b9d0f7fb84268f73cc4f91d9f41c929922340a595f05a50801012d5e452a580f5e2f515b56f53b6809af795b5c8998f72d7ca1d03306ba175238c08fa9ad60467bfd07670926fb58b511b28b6fb3667e62ac352c6fa786685e344ca14a45057b0c9c8724124de02839109e3b3a68032afe923a54f5a9a49b5834ee4a807f12951871226f8a18b708d90bbf70478daa3e312d2f404d6e1da42542045412da01531aff5323721b498f3135239731817d1baf01c6189181ba3ed130448783059329fc95782d004658914e4cf731f2ca32ab462b43fdad35c465e0c1b06c9da86a5d5f09790002cec7a4fad6ffbd9fd1c3b49fcaeef37cc614768cf68be419e53375202ecce35eb74866f16d08044968cdecb66c7b7c45f2e1d0c256f70295c0d339cf9ca1a41862f5d84675a4f7deffbd44080a44f3a10cce74ef40202909fd91392676faeb6d2cf50c44d76b543736387a5cc4fdce96039a5f8fb7b5282743d1eb2dfc6afcad2497289259e3ab619efbbb3850a27b951638d5dd387022ea4482777578907f537dd4ea7601b76f4e427ae6d3c70841467c6d41f26516279e61861affb9329a72c7c4256750f453c2b48d292e99c745a90ddf7507ec4bf61a8f1199b4c7fd1fc4d412cbb80bd4c57d83347d67bf19c632bb5752e0d424733af1aa8d5318387f786608f0f0408d78236ab365e6d5fff2a4a3f8703f9012087052007b8dc08e482347b1bbd744317c649aa9f6a7e47fee4cd21af2861d726a7a755d377fabf37a26b95884194550b032786ff7b41c98b213e7de62ac3642bf2674b4d0f94a1f22552b4b221046e4718b1aaa780f3ce1a228a59fa8dd84c9e083057a01824a4d03f51df2af965b7ccbad13050296bfb15c72d1032bea62bafc294849d99ea733fcf820c431a56081522bb015602888eb0cc7f6d0de31ca950375bc2d0f201e2871c7150fa07a1656d98eefd0e3b401d5351f303d8c75b690c5e0e9e61e9f9069a7c6dffbf498c1605effe39fc0a82bf05eb3c1b40b16b792afc91b5faee6c044eb5021a36859758fab7ab38e136e8edf95e53c8a05a5d1554c58d21f9bf0fb28a64252551ad08a4348805d6c3b030cbb54297f3ac53739f8da8f23d82f6cec4c4d7b23cbbd6e50dc1064e569f0512261a392c76e0ebec6f9ee2dc1635e767e9ecece71c7a0319e911d789ff62bd80c9007540caf8dc4396e6cd68de5defde08cebcf720e9f42f6d1a7c942fcf1dcea0b6fef58aabaa64e6fe580146afcec8caf7f64d11ffc46188d2578c5a95b1d4d4f07a6571c1bf84fc3f4b0706e8c5f2248920fb5d63eecbfca681905583c52f6c8f2a4b050ac6d4f4866360617899304b11ae438610b23546abcfbeb5633e31d9e41277525378adfd754fd8e9e57e07a484813d8c1016b121e9ea2f8e08159c834aa656fab10011d906ee8e8b0e95218a694e0185315ab63c4ac0c7a4d5597a7ca2105804bfd0e3368c1e1146df2611089ec0ef59e85100a99b2106b9422107cc4591163ab7ebe132bcda880bb4cfd8fd239cbe541295d1c7511ca85106fffefa07fa9c4fb3314208e7f795232d5edea3b37c685dfe9533dc97dd7cfdd2ebbc2db9608ee284ddf09a7dc48d90cf5ee64d5a50dfbbf08324388c725022a78cd6b7c5c3e78219688a55295bb7459187089f16b1960f2145b84d8739ea8ac25032b877c9589f20f3d2b013dfe6f4d17e0d569a3ccf8eaeea653c202a52cc183629b477ca49c0bde74563dfe2b571ce0366a960724650b9fcb17df3ce5cadcd87a8b78defe61b399bc21642f5db18354605cf46f8d46c3ea48a26be59de555892809a0a07c3f9f9c94c62798d903aea168813ebf6060ef74c16cf7adce21e5ba6059dbbdfbd0ba169bf404d6d02c755e7376b21a9bab223cfd0febd7ee1dc733729fe64f9f6ffd161a80833cf72cfce6ff4fefe9483ada3e4586ef64161c41a9718d487fd2455209b4385d21ce6fc0bf3496c5fb02c37ee948fc1ee43e518027101996bcaa1be95de9e4d8f5ef70a0cf3602b45b6a3a085ba5ecfa0cea3de56fbdb26fd11c2d2775622e11c903b226dceea8787afc8ecefba0bf722b2c8d82f0e759e8e6b732ee7c050b5d6b833b5a3e2e4b23ea226a35dadc64b8b22243a930ab222e24d16f84684345090a033a7c99c464f6641169fcdb266387c2fe6cd958bf2a7e9d190841f3da5a262d429445d92993a0c5a64f860be24bb1e862fd6bbc12bb07bbef6c111225803f865de890d0c5701a97da0a40a937841ac7029cada5ec97e6912e66551d44ca28214b5b70e555e8b7a43f6cb098601a1c916d209576991ec9e4ccdf691771183e27381c9139a1aade2941b7093ed45ff1d9587a9db568abe0180c4464863b2b0a5649e8df03ace167127bbfda7f4a9435c1067f7f8d8640b1733f7de1f48dc31124a6509ebdb53086c39b03dc707ee0d375beb4a895cf08499d48e0827674daa796c07ed5498effd7b0fa639c719dd573f91ccdfcbc5733547f14ee7563ff8825acccd3791f35c39be1529124155f5745cba5942d51debee7342149edcbad5bf7bd8f90b7e5d6687ceb31cf6ab646ac28ce312975ae8c334111d5c261bfe2ef5d3e808e5ed8f9eb5c339d109a59992af941c1022b6266864d16824a7d234c7134f401a6358329ff610d655d485175a7d329f4b8b8bdd9fee560b7bdb1b0f2613791ff8ee89d956e522e4ecb9625a359a6cf9a64f216b21f9de2cb593ae650e04f2941014c7dc1251ae734677046a56926fde599f9b21ef774de519b1b1224542acb96ad3c5ec8f3877e67743315c7a199af05ce0621276d5781578aa0f8da8cf91cee321de4b8efae4cf3a51677f1f228b91b3fb8ba2228344a6dc60fa5534c62964559fe79b5d05a792968af883c3718dbcd13a68bf25419692821bdf007607efb7fbc9f64c56020410e6c814469675f6488d4450641b9dcf18092c48b093e82900b0e415a5082d5a54959b5530fda06bc8ae08cad912759141d079e44938597c546a6f1ee4cf88f7858e9436105b3e15c183b742cdb2d8784b08a0d870f80b8bd44fcccdeb84b8013b3a8cfc31613376c746c2716b56f705830a8cca8e21c3ec31ed70364ab55f3ab23030e37608876ceeef3a92eb192aff45c2e871a03f044853b17f92b7adf1070c350137dddd5a584d59c9e093bc03bee4c31dc5a62c68aca2420ee7bfe8327968e936cbb8d079141943ae41da1e2fffdd1283cca6f32a79ca4d4470c8eb470cf45ade5184c5c8bb547b5cb7835d405b75c1ea22827dfd8d5494c7aaecfb41fd6056b2fd2727769fa4c7f3c46fe7dcab2bcdff4e0bb187a7bdff1394570a73adb39581fc2756ff91d84f98db90d1fbdd0f985e8059eafa06cb2c01fd2bcad9d68a35712c4421f30d158ad3f4a062876775a2ce08598b3abf5a0d62f672033e428a7c0453ffa582fdf33492da7ec15f81b99c8d6bad240e636705e7adb7eef31d02a053db3daf49bd3c033f5a65c3065406d525d97b542c34f1a078d894d0099cbee8ad75aae27aee29fd17b3af7e6090d2ab520b87e5e5f4a6c586a6a672ff8c57cff3fca1db1c582e45ca1b5296dcf0107149a4e6551b4150afe3d50ed3b9aa5ffe089e8d28f9ec912f01812a5073257255a152aa4ea5d7093776938eac0ee5bac5680f136f61a055ad9bab012472db7fd11a7a0f4a99df03ca28d9841aebbee3d29cbb87df1a59da1ec4529f717d7084d58fd44cca531612004091441f3ea907cd6c3b92ffa6859419cea9780363f8d891e5f3b28f6a9eef87d494a36b1e880d1043098b8c9a411854f4344a9f1d49272beb7f0aa52d75967f1e5ec38b4091b66f26d3aea7c7962cabcf4407fc84dcbbdf6fe422520bcddc972acefd648a4b864de1d157cbf6cd96e3d8eed8885ee7361e2d4e10636ea765503186a86bf56b3bbbf724755179f6b87568d976dfe4685e4844e0ac4ef087510d555f6d12a46a52e3b07bb474a290181e65dcf83beec43831c31d91dfc1ec44376628e0c4ee95b0ca7b3bed346b121faec3dd1e5373074a10aa663f50d87d3b95e14a2b6775705ce2931f5dc52d13238005da5b5af0a8c9d6b8093a1a3bbe93e1a7dd53f537d5a45a5fe8f5341bc8a684fd947f07042d8b8c473d774292308896b2705e7fa312a7fed5f3a95e824c62cff09c4ef959df426e117d35966d53901d12155f39784d676b77077709a54104a0512386cd22a3696c34b7bd19647c7f370e78963f384108f6b45d95466d726874cb21666948ca03cfb906c1a9aeef8662cd5090e7a8b880f17a0163f61b0595e6050de20cd84e104de2e0e0f8ba33198919c3397bddb72e444a04643da1c4e28cfad7706f1c77b9b0dca5e884df6dcf6f06dbbd78387301e5ad724f5d000a7e79b43780107ce3d784a46ea667c81ee98a72b0299855ed5643d0bc2058a8f46b295544c4d9d47baccc8972fd01980533192b9e343ec1c83ea619790aae5e1e40f8005f24417a6f074b6f914c74cb370480bc17ee263a0eb34227f2d088e690802774bf4eb5a4a710e7a95b20caa3077e76ac1efbd689b141b35e376617261c7e2a8cb53b4a87cd5dfc1a1bb5330cdf5a40c48bff11fc8b10eac36b06094b3205d59daabee3290dd41681b2f87b31ec94c8175f4b87d2cee764ffb58af1d94bda4307ad3122f418b25ec3276014d82ae8f501224bc64169fd3164a24b91d718a0f4956e0c8bbf84d2c45ad99a92fb23147b74df7ef7005105e9cb5396a8f09e81b4eac83cbd2dc8259aa49d5478c781576edfbd53d34a67e1a14d05240d041d66bd5bd4079b426ddbba8b2d785bcc9e9d5b07dc6533159dc455c1c405afbd68ba23bd2a114e5c71e91b9d247c0aa2d5e03459d076527895e597526a9904b931a8c43ecdfb7f2be6c2aaca3829ec0212846de8a98e0ff47c9d76d5913360676848eceeb5ed5fc5b507902a20633ef28f09498eeeec88ab3c8107317099cc77a01524898d88947be01e4083b47ba32cf7fb74a48626e31d2014a6742566ef09902a388ccab1c933e6563fa13be50bdb5682ee28fb7a64987ba947343b5773b671e37852e379223cda491efb3a757356008f793093f6f8d1a397eacce735643e36bfa99f2b46bbee8bf0ff53121861b9a7791bba102c43c8bd22b62f0d8291865d408ef15cae98576c328d228686c9cb8cbe48f037c04337177c25a135e718b834c22085d18acc8a2a8e46e4a27325be63779d78e98735d3847443dc2d5d146923435af58f8907c3316f2ec01ce5d571ba7a4582b83545d3af89ade51e0229911e9be5850a73143eb66f8dc9812deeb22e696bf17b7cb1870d2a10ca3e518d3e83674916d403cd62528f88ba996bbbd15f5b68811eced9c1296e01b11445c83910c61417cf1514346baea7d182e3a1d81a59799ea8b475c64e6bf07b3f5c11e41b10d31e9e7d1eeb743f391a64f0b6184c191403dc561cb1e7f77a9c0291fda35a201c505eff53b50b17fa6177c2373cc3fe3ca4a2cd23faa3cb6abdae41fe4b8ec977d25f14420b6d060c29c25b47c8ad6bec008f7062b4a928afe8bc7d6e6ee2f6fcdbab17cfc08fc669b6e04d10260946a9dfb79704bf4326df95defc826c3fac0b106dc1c6bf7db411cfbbf9ba100f1b83eb95aa4e6f1fd2b08119bb6e8351f3e373fdefb35fb7fddcc173d1c30d89e34118500c0e37fe64bef09499c2d6b504eecdac9a4d24b3679dfcb0f44987c6d013d20ede352aa3ea170ab960baaddc1fc32118d916b9df67605c7b00e594b385276dfdcd40011b107cc0b44c9a7a9dd2d694d4a27094628e6fa00c51aa78d975ce0438353686e1170d7c66752e9701478fa1f16f3aee3440f83213e4baffffe14200529b8bec5e7bde0c63b10d0c6c807d68fd460571b1d2bc571e0a9ef1d166657aab721ea0a6e37f65c9c4da12af36927f900f3a3f20072d2161845f1b99d1d1f6a5d81ec9f98707f0046c6659527be068cb5aed22a9f2089ae0f93629a2769779e4aee0975ab75fc4561281fc8b224fb3f6561521c46ea4c9d61cc1b7006dc3fd1e0b97078ecbcab1535df1ed6a8831f37807baf8b5a0ef6be59ca45e5b0e04df431be3bd299c6c9da5241919941d62484085dfc363ad98ddbaced6a421aea375cdb2c85b01889ddc4432864870f27f9760a2d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"85395473ba430cba10d4b07f726120bf"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
